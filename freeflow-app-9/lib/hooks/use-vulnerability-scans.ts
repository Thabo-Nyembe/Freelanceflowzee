'use client'

import { createClient } from '@/lib/supabase/client'
import { useEffect, useState, useCallback } from 'react'
import { useToast } from '@/components/ui/use-toast'

// Types
export interface VulnerabilityScan {
  id: string
  user_id: string
  scan_code: string
  name: string
  description: string | null
  scan_type: 'dependency' | 'code' | 'container' | 'infrastructure' | 'web-application' | 'network' | 'api'
  status: 'scheduled' | 'in-progress' | 'completed' | 'failed' | 'cancelled'
  scanner: string | null
  scanner_version: string | null
  target: string | null
  target_type: string | null
  started_at: string | null
  completed_at: string | null
  duration_seconds: number
  scanned_items: number
  vuln_critical: number
  vuln_high: number
  vuln_medium: number
  vuln_low: number
  vuln_info: number
  fixed_count: number
  ignored_count: number
  false_positive_count: number
  report_url: string | null
  schedule_cron: string | null
  next_scheduled_at: string | null
  config: Record<string, any>
  tags: string[]
  metadata: Record<string, any>
  created_at: string
  updated_at: string
  deleted_at: string | null
}

export interface Vulnerability {
  id: string
  scan_id: string
  vuln_code: string | null
  title: string
  description: string | null
  severity: 'info' | 'low' | 'medium' | 'high' | 'critical'
  category: string | null
  package_name: string | null
  package_version: string | null
  fixed_version: string | null
  file_path: string | null
  line_number: number | null
  cve_id: string | null
  cwe_id: string | null
  cvss_score: number | null
  cvss_vector: string | null
  exploit_available: boolean
  patch_available: boolean
  status: 'open' | 'in-progress' | 'fixed' | 'ignored' | 'false-positive' | 'accepted'
  fixed_at: string | null
  fixed_by: string | null
  remediation_notes: string | null
  reference_urls: string[]
  metadata: Record<string, any>
  created_at: string
  updated_at: string
}

export interface ScanStats {
  total: number
  scheduled: number
  inProgress: number
  completed: number
  failed: number
  totalVulnerabilities: number
  criticalCount: number
  highCount: number
  fixedCount: number
  fixRate: number
}

export function useVulnerabilityScans() {
  const supabase = createClient()
  const { toast } = useToast()
  const [scans, setScans] = useState<VulnerabilityScan[]>([])
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)

  const fetchScans = useCallback(async () => {
    try {
      setLoading(true)
      const { data: { user } } = await supabase.auth.getUser()
      if (!user) return

      const { data, error } = await supabase
        .from('vulnerability_scans')
        .select('*')
        .eq('user_id', user.id)
        .is('deleted_at', null)
        .order('created_at', { ascending: false })

      if (error) throw error
      setScans(data || [])
    } catch (err: any) {
      setError(err.message)
      toast({ title: 'Error', description: 'Failed to fetch scans', variant: 'destructive' })
    } finally {
      setLoading(false)
    }
  }, [supabase, toast])

  const createScan = async (scan: Partial<VulnerabilityScan>) => {
    try {
      const { data: { user } } = await supabase.auth.getUser()
      if (!user) throw new Error('Not authenticated')

      const { data, error } = await supabase
        .from('vulnerability_scans')
        .insert([{ ...scan, user_id: user.id }])
        .select()
        .single()

      if (error) throw error
      setScans(prev => [data, ...prev])
      toast({ title: 'Success', description: 'Scan scheduled successfully' })
      return data
    } catch (err: any) {
      toast({ title: 'Error', description: err.message, variant: 'destructive' })
      throw err
    }
  }

  const updateScan = async (id: string, updates: Partial<VulnerabilityScan>) => {
    try {
      const { data, error } = await supabase
        .from('vulnerability_scans')
        .update(updates)
        .eq('id', id)
        .select()
        .single()

      if (error) throw error
      setScans(prev => prev.map(s => s.id === id ? data : s))
      toast({ title: 'Success', description: 'Scan updated' })
      return data
    } catch (err: any) {
      toast({ title: 'Error', description: err.message, variant: 'destructive' })
      throw err
    }
  }

  const deleteScan = async (id: string) => {
    try {
      const { error } = await supabase
        .from('vulnerability_scans')
        .update({ deleted_at: new Date().toISOString() })
        .eq('id', id)

      if (error) throw error
      setScans(prev => prev.filter(s => s.id !== id))
      toast({ title: 'Success', description: 'Scan deleted' })
    } catch (err: any) {
      toast({ title: 'Error', description: err.message, variant: 'destructive' })
      throw err
    }
  }

  const startScan = async (id: string) => {
    return updateScan(id, {
      status: 'in-progress',
      started_at: new Date().toISOString()
    })
  }

  const completeScan = async (id: string, success: boolean = true) => {
    const scan = scans.find(s => s.id === id)
    const startedAt = scan?.started_at ? new Date(scan.started_at) : new Date()
    const duration = Math.floor((Date.now() - startedAt.getTime()) / 1000)

    return updateScan(id, {
      status: success ? 'completed' : 'failed',
      completed_at: new Date().toISOString(),
      duration_seconds: duration
    })
  }

  const cancelScan = async (id: string) => {
    return updateScan(id, { status: 'cancelled' })
  }

  const rescan = async (id: string) => {
    const scan = scans.find(s => s.id === id)
    if (!scan) return

    return createScan({
      name: scan.name,
      description: scan.description,
      scan_type: scan.scan_type,
      scanner: scan.scanner,
      target: scan.target,
      target_type: scan.target_type,
      config: scan.config,
      tags: scan.tags
    })
  }

  const getStats = useCallback((): ScanStats => {
    const totalVulns = scans.reduce((sum, s) =>
      sum + s.vuln_critical + s.vuln_high + s.vuln_medium + s.vuln_low, 0
    )
    const totalFixed = scans.reduce((sum, s) => sum + s.fixed_count, 0)

    return {
      total: scans.length,
      scheduled: scans.filter(s => s.status === 'scheduled').length,
      inProgress: scans.filter(s => s.status === 'in-progress').length,
      completed: scans.filter(s => s.status === 'completed').length,
      failed: scans.filter(s => s.status === 'failed').length,
      totalVulnerabilities: totalVulns,
      criticalCount: scans.reduce((sum, s) => sum + s.vuln_critical, 0),
      highCount: scans.reduce((sum, s) => sum + s.vuln_high, 0),
      fixedCount: totalFixed,
      fixRate: totalVulns > 0 ? (totalFixed / totalVulns) * 100 : 0
    }
  }, [scans])

  useEffect(() => {
    fetchScans()

    const channel = supabase
      .channel('vulnerability-scans-changes')
      .on('postgres_changes', { event: '*', schema: 'public', table: 'vulnerability_scans' }, (payload) => {
        if (payload.eventType === 'INSERT') {
          setScans(prev => [payload.new as VulnerabilityScan, ...prev])
        } else if (payload.eventType === 'UPDATE') {
          setScans(prev => prev.map(s => s.id === payload.new.id ? payload.new as VulnerabilityScan : s))
        } else if (payload.eventType === 'DELETE') {
          setScans(prev => prev.filter(s => s.id !== payload.old.id))
        }
      })
      .subscribe()

    return () => {
      supabase.removeChannel(channel)
    }
  }, [fetchScans, supabase])

  return {
    scans,
    loading,
    error,
    fetchScans,
    createScan,
    updateScan,
    deleteScan,
    startScan,
    completeScan,
    cancelScan,
    rescan,
    getStats
  }
}

// Hook for vulnerabilities
export function useVulnerabilities(scanId: string) {
  const supabase = createClient()
  const { toast } = useToast()
  const [vulnerabilities, setVulnerabilities] = useState<Vulnerability[]>([])
  const [loading, setLoading] = useState(true)

  const fetchVulnerabilities = useCallback(async () => {
    if (!scanId) return
    try {
      setLoading(true)
      const { data, error } = await supabase
        .from('vulnerabilities')
        .select('*')
        .eq('scan_id', scanId)
        .order('severity', { ascending: false })

      if (error) throw error
      setVulnerabilities(data || [])
    } catch (err) {
      console.error('Failed to fetch vulnerabilities:', err)
    } finally {
      setLoading(false)
    }
  }, [scanId, supabase])

  const addVulnerability = async (vuln: Partial<Vulnerability>) => {
    try {
      const { data, error } = await supabase
        .from('vulnerabilities')
        .insert([{ ...vuln, scan_id: scanId }])
        .select()
        .single()

      if (error) throw error
      setVulnerabilities(prev => [...prev, data])
      return data
    } catch (err: any) {
      toast({ title: 'Error', description: err.message, variant: 'destructive' })
      throw err
    }
  }

  const updateVulnerability = async (id: string, updates: Partial<Vulnerability>) => {
    try {
      const { data, error } = await supabase
        .from('vulnerabilities')
        .update(updates)
        .eq('id', id)
        .select()
        .single()

      if (error) throw error
      setVulnerabilities(prev => prev.map(v => v.id === id ? data : v))
      toast({ title: 'Success', description: 'Vulnerability updated' })
      return data
    } catch (err: any) {
      toast({ title: 'Error', description: err.message, variant: 'destructive' })
      throw err
    }
  }

  const fixVulnerability = async (id: string, notes?: string) => {
    const { data: { user } } = await supabase.auth.getUser()
    return updateVulnerability(id, {
      status: 'fixed',
      fixed_at: new Date().toISOString(),
      fixed_by: user?.id,
      remediation_notes: notes
    })
  }

  const ignoreVulnerability = async (id: string, reason?: string) => {
    return updateVulnerability(id, {
      status: 'ignored',
      remediation_notes: reason
    })
  }

  const markFalsePositive = async (id: string, reason?: string) => {
    return updateVulnerability(id, {
      status: 'false-positive',
      remediation_notes: reason
    })
  }

  useEffect(() => {
    fetchVulnerabilities()

    if (scanId) {
      const channel = supabase
        .channel(`vulnerabilities-${scanId}`)
        .on('postgres_changes', {
          event: '*',
          schema: 'public',
          table: 'vulnerabilities',
          filter: `scan_id=eq.${scanId}`
        }, (payload) => {
          if (payload.eventType === 'INSERT') {
            setVulnerabilities(prev => [...prev, payload.new as Vulnerability])
          } else if (payload.eventType === 'UPDATE') {
            setVulnerabilities(prev => prev.map(v => v.id === payload.new.id ? payload.new as Vulnerability : v))
          }
        })
        .subscribe()

      return () => {
        supabase.removeChannel(channel)
      }
    }
  }, [fetchVulnerabilities, scanId, supabase])

  return {
    vulnerabilities,
    loading,
    addVulnerability,
    updateVulnerability,
    fixVulnerability,
    ignoreVulnerability,
    markFalsePositive
  }
}
