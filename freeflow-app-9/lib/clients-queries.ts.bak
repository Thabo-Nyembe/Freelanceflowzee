/**
 * Clients Management - Database Queries
 *
 * CRM functionality with full client lifecycle management
 * Full CRUD operations for Clients feature
 */

import { createClient } from '@/lib/supabase/client'
import { createFeatureLogger } from './logger'

const supabase = createClient()
const logger = createFeatureLogger('ClientsQueries')

// ============================================================================
// TYPE DEFINITIONS
// ============================================================================

export interface Client {
  id: string
  user_id: string
  name: string
  email: string
  phone?: string
  company?: string
  position?: string
  avatar?: string
  status: 'active' | 'inactive' | 'lead' | 'prospect' | 'churned' | 'vip'
  type: 'individual' | 'business' | 'enterprise' | 'agency' | 'nonprofit'
  priority: 'low' | 'medium' | 'high' | 'urgent'
  address?: string
  city?: string
  state?: string
  country?: string
  postal_code?: string
  timezone?: string
  website?: string
  industry?: string
  company_size?: string
  total_revenue: number
  lifetime_value: number
  average_project_value: number
  currency: string
  projects_count: number
  completed_projects: number
  active_projects: number
  health_score: number
  lead_score: number
  satisfaction_score: number
  last_contact?: string
  next_follow_up?: string
  communication_frequency: number
  tags: string[]
  categories: string[]
  linkedin_url?: string
  twitter_url?: string
  facebook_url?: string
  notes?: string
  internal_notes?: string
  created_at: string
  updated_at: string
  last_activity_at?: string
}

export interface ClientStats {
  total: number
  active: number
  leads: number
  prospects: number
  vip: number
  churned: number
  totalRevenue: number
  averageLifetimeValue: number
  averageHealthScore: number
}

export interface ClientFilters {
  status?: string[]
  type?: string[]
  priority?: string[]
  search?: string
  tags?: string[]
  minHealthScore?: number
  maxHealthScore?: number
}

export interface ClientSortOptions {
  field: 'name' | 'company' | 'created_at' | 'last_contact' | 'total_revenue' | 'health_score'
  direction: 'asc' | 'desc'
}

// ============================================================================
// QUERY FUNCTIONS
// ============================================================================

/**
 * Get all clients for a user with optional filtering and sorting
 */
export async function getClients(
  userId: string,
  filters?: ClientFilters,
  sort?: ClientSortOptions,
  limit?: number,
  offset?: number
): Promise<{ data: Client[]; error: any; count: number }> {
  logger.info('Fetching clients', { userId, filters, sort, limit, offset })

  try {
    let query = supabase
      .from('clients')
      .select('*', { count: 'exact' })
      .eq('user_id', userId)

    // Apply filters
    if (filters) {
      if (filters.status && filters.status.length > 0) {
        query = query.in('status', filters.status)
      }
      if (filters.type && filters.type.length > 0) {
        query = query.in('type', filters.type)
      }
      if (filters.priority && filters.priority.length > 0) {
        query = query.in('priority', filters.priority)
      }
      if (filters.search) {
        query = query.or(`name.ilike.%${filters.search}%,email.ilike.%${filters.search}%,company.ilike.%${filters.search}%`)
      }
      if (filters.minHealthScore !== undefined) {
        query = query.gte('health_score', filters.minHealthScore)
      }
      if (filters.maxHealthScore !== undefined) {
        query = query.lte('health_score', filters.maxHealthScore)
      }
      if (filters.tags && filters.tags.length > 0) {
        query = query.contains('tags', filters.tags)
      }
    }

    // Apply sorting
    if (sort) {
      query = query.order(sort.field, { ascending: sort.direction === 'asc' })
    } else {
      // Default sort: by health score desc, then by name
      query = query.order('health_score', { ascending: false })
      query = query.order('name', { ascending: true })
    }

    // Apply pagination
    if (limit) {
      query = query.limit(limit)
    }
    if (offset) {
      query = query.range(offset, offset + (limit || 10) - 1)
    }

    const { data, error, count } = await query

    if (error) {
      logger.error('Failed to fetch clients', { error, userId })
      return { data: [], error, count: 0 }
    }

    logger.info('Clients fetched successfully', { count: data?.length || 0, total: count })
    return { data: data || [], error: null, count: count || 0 }
  } catch (error) {
    logger.error('Exception fetching clients', { error, userId })
    return { data: [], error, count: 0 }
  }
}

/**
 * Get a single client by ID
 */
export async function getClient(clientId: string): Promise<{ data: Client | null; error: any }> {
  logger.info('Fetching client', { clientId })

  try {
    const { data, error } = await supabase
      .from('clients')
      .select('*')
      .eq('id', clientId)
      .single()

    if (error) {
      logger.error('Failed to fetch client', { error, clientId })
      return { data: null, error }
    }

    logger.info('Client fetched successfully', { clientId, name: data?.name })
    return { data, error: null }
  } catch (error) {
    logger.error('Exception fetching client', { error, clientId })
    return { data: null, error }
  }
}

/**
 * Create a new client
 */
export async function createClient(
  userId: string,
  clientData: Partial<Client>
): Promise<{ data: Client | null; error: any }> {
  logger.info('Creating client', { userId, name: clientData.name, email: clientData.email })

  try {
    const { data, error } = await supabase
      .from('clients')
      .insert([
        {
          user_id: userId,
          name: clientData.name,
          email: clientData.email,
          phone: clientData.phone,
          company: clientData.company,
          position: clientData.position,
          avatar: clientData.avatar,
          status: clientData.status || 'lead',
          type: clientData.type || 'individual',
          priority: clientData.priority || 'medium',
          address: clientData.address,
          city: clientData.city,
          state: clientData.state,
          country: clientData.country,
          postal_code: clientData.postal_code,
          timezone: clientData.timezone,
          website: clientData.website,
          industry: clientData.industry,
          company_size: clientData.company_size,
          currency: clientData.currency || 'USD',
          tags: clientData.tags || [],
          categories: clientData.categories || [],
          linkedin_url: clientData.linkedin_url,
          twitter_url: clientData.twitter_url,
          facebook_url: clientData.facebook_url,
          notes: clientData.notes,
          internal_notes: clientData.internal_notes,
        },
      ])
      .select()
      .single()

    if (error) {
      logger.error('Failed to create client', { error, userId, name: clientData.name })
      return { data: null, error }
    }

    logger.info('Client created successfully', { clientId: data?.id, name: data?.name })
    return { data, error: null }
  } catch (error) {
    logger.error('Exception creating client', { error, userId, name: clientData.name })
    return { data: null, error }
  }
}

/**
 * Update an existing client
 */
export async function updateClient(
  clientId: string,
  updates: Partial<Client>
): Promise<{ data: Client | null; error: any }> {
  logger.info('Updating client', { clientId, updates: Object.keys(updates) })

  try {
    const { data, error } = await supabase
      .from('clients')
      .update({
        ...updates,
        updated_at: new Date().toISOString(),
      })
      .eq('id', clientId)
      .select()
      .single()

    if (error) {
      logger.error('Failed to update client', { error, clientId })
      return { data: null, error }
    }

    logger.info('Client updated successfully', { clientId, name: data?.name })
    return { data, error: null }
  } catch (error) {
    logger.error('Exception updating client', { error, clientId })
    return { data: null, error }
  }
}

/**
 * Delete a client
 */
export async function deleteClient(clientId: string): Promise<{ success: boolean; error: any }> {
  logger.info('Deleting client', { clientId })

  try {
    const { error } = await supabase
      .from('clients')
      .delete()
      .eq('id', clientId)

    if (error) {
      logger.error('Failed to delete client', { error, clientId })
      return { success: false, error }
    }

    logger.info('Client deleted successfully', { clientId })
    return { success: true, error: null }
  } catch (error) {
    logger.error('Exception deleting client', { error, clientId })
    return { success: false, error }
  }
}

/**
 * Update client status
 */
export async function updateClientStatus(
  clientId: string,
  status: Client['status']
): Promise<{ data: Client | null; error: any }> {
  logger.info('Updating client status', { clientId, status })

  return updateClient(clientId, { status })
}

/**
 * Update client health score
 */
export async function updateClientHealthScore(
  clientId: string,
  healthScore: number
): Promise<{ data: Client | null; error: any }> {
  logger.info('Updating client health score', { clientId, healthScore })

  return updateClient(clientId, { health_score: healthScore })
}

/**
 * Update client lead score
 */
export async function updateClientLeadScore(
  clientId: string,
  leadScore: number
): Promise<{ data: Client | null; error: any }> {
  logger.info('Updating client lead score', { clientId, leadScore })

  return updateClient(clientId, { lead_score: leadScore })
}

/**
 * Get client statistics
 */
export async function getClientStats(userId: string): Promise<ClientStats> {
  logger.info('Fetching client stats', { userId })

  try {
    const { data, error } = await supabase
      .from('clients')
      .select('status, total_revenue, lifetime_value, health_score')
      .eq('user_id', userId)

    if (error) {
      logger.error('Failed to fetch client stats', { error, userId })
      throw error
    }

    const clients = data || []

    const stats: ClientStats = {
      total: clients.length,
      active: clients.filter((c) => c.status === 'active').length,
      leads: clients.filter((c) => c.status === 'lead').length,
      prospects: clients.filter((c) => c.status === 'prospect').length,
      vip: clients.filter((c) => c.status === 'vip').length,
      churned: clients.filter((c) => c.status === 'churned').length,
      totalRevenue: clients.reduce((sum, c) => sum + (c.total_revenue || 0), 0),
      averageLifetimeValue: clients.length > 0
        ? clients.reduce((sum, c) => sum + (c.lifetime_value || 0), 0) / clients.length
        : 0,
      averageHealthScore: clients.length > 0
        ? clients.reduce((sum, c) => sum + (c.health_score || 0), 0) / clients.length
        : 0,
    }

    logger.info('Client stats calculated', { stats })
    return stats
  } catch (error) {
    logger.error('Exception calculating client stats', { error, userId })
    return {
      total: 0,
      active: 0,
      leads: 0,
      prospects: 0,
      vip: 0,
      churned: 0,
      totalRevenue: 0,
      averageLifetimeValue: 0,
      averageHealthScore: 0,
    }
  }
}

/**
 * Search clients by name, email, or company
 */
export async function searchClients(
  userId: string,
  searchTerm: string,
  limit: number = 10
): Promise<{ data: Client[]; error: any }> {
  logger.info('Searching clients', { userId, searchTerm, limit })

  return getClients(
    userId,
    { search: searchTerm },
    { field: 'name', direction: 'asc' },
    limit
  ).then(({ data, error }) => ({ data, error }))
}

/**
 * Get clients by status
 */
export async function getClientsByStatus(
  userId: string,
  status: Client['status'][]
): Promise<{ data: Client[]; error: any }> {
  logger.info('Fetching clients by status', { userId, status })

  return getClients(
    userId,
    { status },
    { field: 'name', direction: 'asc' }
  ).then(({ data, error }) => ({ data, error }))
}

/**
 * Get VIP clients
 */
export async function getVIPClients(
  userId: string
): Promise<{ data: Client[]; error: any }> {
  logger.info('Fetching VIP clients', { userId })

  return getClientsByStatus(userId, ['vip'])
}

/**
 * Get recent clients (last created)
 */
export async function getRecentClients(
  userId: string,
  limit: number = 5
): Promise<{ data: Client[]; error: any }> {
  logger.info('Fetching recent clients', { userId, limit })

  return getClients(
    userId,
    undefined,
    { field: 'created_at', direction: 'desc' },
    limit
  ).then(({ data, error }) => ({ data, error }))
}

/**
 * Get clients needing follow-up
 */
export async function getClientsNeedingFollowUp(
  userId: string
): Promise<{ data: Client[]; error: any }> {
  logger.info('Fetching clients needing follow-up', { userId })

  try {
    const { data, error } = await supabase
      .from('clients')
      .select('*')
      .eq('user_id', userId)
      .not('next_follow_up', 'is', null)
      .lte('next_follow_up', new Date().toISOString())
      .order('next_follow_up', { ascending: true })

    if (error) {
      logger.error('Failed to fetch clients needing follow-up', { error, userId })
      return { data: [], error }
    }

    logger.info('Clients needing follow-up fetched', { count: data?.length || 0 })
    return { data: data || [], error: null }
  } catch (error) {
    logger.error('Exception fetching clients needing follow-up', { error, userId })
    return { data: [], error }
  }
}
