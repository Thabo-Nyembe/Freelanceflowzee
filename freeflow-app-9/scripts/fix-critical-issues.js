#!/usr/bin/env node

const { exec } = require('child_process');
const fs = require('fs');
const path = require('path');

class CriticalIssueFixer {
  constructor() {
    this.fixes = [];
    this.issues = [];
  }

  async executeCommand(command) {
    return new Promise((resolve) => {
      exec(command, { maxBuffer: 1024 * 1024 * 10 }, (error, stdout, stderr) => {
        resolve({
          success: !error,
          stdout: stdout || '',
          stderr: stderr || '',
          error: error
        });
      });
    });
  }

  async log(message) {
    console.log(`[${new Date().toISOString()}] ${message}`);
  }

  async fixWebpackCache() {
    await this.log('ðŸ”§ Fixing webpack cache corruption...');
    
    const commands = [
      'rm -rf .next',
      'rm -rf node_modules/.cache',
      'rm -rf test-results',
      'rm -rf playwright-report',
      'rm -rf tsconfig.tsbuildinfo'
    ];
    
    for (const cmd of commands) {
      const result = await this.executeCommand(cmd);
      if (result.success) {
        await this.log(`âœ… Executed: ${cmd}`);
      } else {
        await this.log(`âš ï¸ Failed: ${cmd} - ${result.stderr}`);
      }
    }
    
    this.fixes.push('Cleared webpack cache corruption');
  }

  async fixAvatarServing() {
    await this.log('ðŸ–¼ï¸ Fixing avatar serving...');
    
    // Verify avatars exist
    const avatarDir = 'public/avatars';
    const requiredAvatars = ['alice.jpg', 'bob.jpg', 'jane.jpg', 'john.jpg', 'mike.jpg', 'client-1.jpg'];
    
    if (!fs.existsSync(avatarDir)) {
      fs.mkdirSync(avatarDir, { recursive: true });
      await this.log('âœ… Created avatars directory');
    }
    
    let missingCount = 0;
    for (const avatar of requiredAvatars) {
      const filePath = path.join(avatarDir, avatar);
      if (!fs.existsSync(filePath)) {
        missingCount++;
        await this.log(`âŒ Missing avatar: ${avatar}`);
      } else {
        // Verify file is readable
        try {
          fs.accessSync(filePath, fs.constants.R_OK);
          await this.log(`âœ… Avatar verified: ${avatar}`);
        } catch (error) {
          await this.log(`âš ï¸ Avatar not readable: ${avatar}`);
        }
      }
    }
    
    if (missingCount === 0) {
      this.fixes.push('Avatar system verified - all 6 avatars present');
    } else {
      this.issues.push(`${missingCount} avatars missing or not accessible`);
    }
  }

  async testBuild() {
    await this.log('ðŸ—ï¸ Testing build after fixes...');
    
    const result = await this.executeCommand('npm run build');
    if (result.success) {
      await this.log('âœ… Build successful after fixes');
      this.fixes.push('Build process validated');
      return true;
    } else {
      await this.log(`âŒ Build still failing: ${result.stderr}`);
      this.issues.push('Build process still has issues');
      return false;
    }
  }

  async generateReport() {
    const report = `# ðŸ”§ Critical Issues Fix Report
**Generated:** ${new Date().toISOString()}

## âœ… Fixes Applied
${this.fixes.map(fix => `- âœ… ${fix}`).join('\n') || '- None applied'}

## âš ï¸ Remaining Issues
${this.issues.map(issue => `- âš ï¸ ${issue}`).join('\n') || '- None identified'}

## ðŸŽ¯ Next Steps
${this.issues.length === 0 ? 
  '- Run the unified test runner to validate all fixes\n- Execute `npm run test:unified-runner`' :
  '- Address remaining issues above\n- Re-run this fix script after making manual corrections'
}

---
*Report generated by Critical Issues Fixer v1.0*
`;

    fs.writeFileSync('CRITICAL_FIXES_REPORT.md', report);
    await this.log('ðŸ“„ Fix report saved to CRITICAL_FIXES_REPORT.md');
    
    return report;
  }

  async run() {
    await this.log('ðŸš€ Starting Critical Issues Fix Process');
    
    try {
      await this.fixWebpackCache();
      await this.fixAvatarServing();
      
      await this.log('ðŸ”„ Testing build after all fixes...');
      await this.testBuild();
      
      await this.generateReport();
      
      await this.log('ðŸ Critical fixes completed!');
      await this.log(`âœ… Applied ${this.fixes.length} fixes`);
      await this.log(`âš ï¸ ${this.issues.length} issues remaining`);
      
      return this.issues.length === 0;
      
    } catch (error) {
      await this.log(`ðŸ’¥ Fatal error during fixes: ${error.message}`);
      return false;
    }
  }
}

if (require.main === module) {
  const fixer = new CriticalIssueFixer();
  fixer.run().then(success => {
    console.log(success ? 'ðŸŸ¢ All critical issues fixed!' : 'ðŸŸ¡ Some issues remain - check report');
    process.exit(success ? 0 : 1);
  });
}

module.exports = CriticalIssueFixer; 