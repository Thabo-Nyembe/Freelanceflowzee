'use server'

import { createServerActionClient } from '@supabase/auth-helpers-nextjs'
import { cookies } from 'next/headers'
import { revalidatePath } from 'next/cache'

// Types
export interface VulnerabilityScanInput {
  name: string
  description?: string
  scan_type: 'dependency' | 'code' | 'container' | 'infrastructure' | 'web-application' | 'network' | 'api'
  scanner?: string
  scanner_version?: string
  target?: string
  target_type?: string
  schedule_cron?: string
  next_scheduled_at?: string
  config?: Record<string, any>
  tags?: string[]
  metadata?: Record<string, any>
}

export interface VulnerabilityInput {
  scan_id: string
  title: string
  description?: string
  severity: 'info' | 'low' | 'medium' | 'high' | 'critical'
  category?: string
  package_name?: string
  package_version?: string
  fixed_version?: string
  file_path?: string
  line_number?: number
  cve_id?: string
  cwe_id?: string
  cvss_score?: number
  cvss_vector?: string
  exploit_available?: boolean
  patch_available?: boolean
  reference_urls?: string[]
  metadata?: Record<string, any>
}

// Vulnerability Scan Actions
export async function createVulnerabilityScan(input: VulnerabilityScanInput) {
  const supabase = createServerActionClient({ cookies })

  const { data: { user } } = await supabase.auth.getUser()
  if (!user) throw new Error('Not authenticated')

  const { data, error } = await supabase
    .from('vulnerability_scans')
    .insert([{
      ...input,
      user_id: user.id,
      status: 'scheduled',
      scanned_items: 0,
      vuln_critical: 0,
      vuln_high: 0,
      vuln_medium: 0,
      vuln_low: 0,
      vuln_info: 0,
      fixed_count: 0,
      ignored_count: 0,
      false_positive_count: 0,
      duration_seconds: 0
    }])
    .select()
    .single()

  if (error) throw error

  revalidatePath('/dashboard/vulnerability-scan-v2')
  return data
}

export async function updateVulnerabilityScan(id: string, updates: Partial<VulnerabilityScanInput>) {
  const supabase = createServerActionClient({ cookies })

  const { data: { user } } = await supabase.auth.getUser()
  if (!user) throw new Error('Not authenticated')

  const { data, error } = await supabase
    .from('vulnerability_scans')
    .update({ ...updates, updated_at: new Date().toISOString() })
    .eq('id', id)
    .eq('user_id', user.id)
    .select()
    .single()

  if (error) throw error

  revalidatePath('/dashboard/vulnerability-scan-v2')
  return data
}

export async function deleteVulnerabilityScan(id: string) {
  const supabase = createServerActionClient({ cookies })

  const { data: { user } } = await supabase.auth.getUser()
  if (!user) throw new Error('Not authenticated')

  const { error } = await supabase
    .from('vulnerability_scans')
    .update({ deleted_at: new Date().toISOString() })
    .eq('id', id)
    .eq('user_id', user.id)

  if (error) throw error

  revalidatePath('/dashboard/vulnerability-scan-v2')
  return { success: true }
}

export async function startVulnerabilityScan(id: string) {
  const supabase = createServerActionClient({ cookies })

  const { data: { user } } = await supabase.auth.getUser()
  if (!user) throw new Error('Not authenticated')

  const { data, error } = await supabase
    .from('vulnerability_scans')
    .update({
      status: 'in-progress',
      started_at: new Date().toISOString(),
      updated_at: new Date().toISOString()
    })
    .eq('id', id)
    .eq('user_id', user.id)
    .select()
    .single()

  if (error) throw error

  revalidatePath('/dashboard/vulnerability-scan-v2')
  return data
}

export async function completeVulnerabilityScan(id: string, success: boolean = true) {
  const supabase = createServerActionClient({ cookies })

  const { data: { user } } = await supabase.auth.getUser()
  if (!user) throw new Error('Not authenticated')

  // Get scan to calculate duration
  const { data: scan } = await supabase
    .from('vulnerability_scans')
    .select('started_at')
    .eq('id', id)
    .single()

  const startedAt = scan?.started_at ? new Date(scan.started_at) : new Date()
  const duration = Math.floor((Date.now() - startedAt.getTime()) / 1000)

  const { data, error } = await supabase
    .from('vulnerability_scans')
    .update({
      status: success ? 'completed' : 'failed',
      completed_at: new Date().toISOString(),
      duration_seconds: duration,
      updated_at: new Date().toISOString()
    })
    .eq('id', id)
    .eq('user_id', user.id)
    .select()
    .single()

  if (error) throw error

  revalidatePath('/dashboard/vulnerability-scan-v2')
  return data
}

export async function cancelVulnerabilityScan(id: string) {
  const supabase = createServerActionClient({ cookies })

  const { data: { user } } = await supabase.auth.getUser()
  if (!user) throw new Error('Not authenticated')

  const { data, error } = await supabase
    .from('vulnerability_scans')
    .update({
      status: 'cancelled',
      updated_at: new Date().toISOString()
    })
    .eq('id', id)
    .eq('user_id', user.id)
    .select()
    .single()

  if (error) throw error

  revalidatePath('/dashboard/vulnerability-scan-v2')
  return data
}

export async function rescanVulnerability(id: string) {
  const supabase = createServerActionClient({ cookies })

  const { data: { user } } = await supabase.auth.getUser()
  if (!user) throw new Error('Not authenticated')

  // Get original scan
  const { data: original } = await supabase
    .from('vulnerability_scans')
    .select('*')
    .eq('id', id)
    .eq('user_id', user.id)
    .single()

  if (!original) throw new Error('Scan not found')

  // Create new scan based on original
  const { data, error } = await supabase
    .from('vulnerability_scans')
    .insert([{
      user_id: user.id,
      name: original.name,
      description: original.description,
      scan_type: original.scan_type,
      scanner: original.scanner,
      scanner_version: original.scanner_version,
      target: original.target,
      target_type: original.target_type,
      config: original.config,
      tags: original.tags,
      status: 'scheduled',
      scanned_items: 0,
      vuln_critical: 0,
      vuln_high: 0,
      vuln_medium: 0,
      vuln_low: 0,
      vuln_info: 0,
      fixed_count: 0,
      ignored_count: 0,
      false_positive_count: 0,
      duration_seconds: 0
    }])
    .select()
    .single()

  if (error) throw error

  revalidatePath('/dashboard/vulnerability-scan-v2')
  return data
}

export async function getVulnerabilityScans() {
  const supabase = createServerActionClient({ cookies })

  const { data: { user } } = await supabase.auth.getUser()
  if (!user) return []

  const { data, error } = await supabase
    .from('vulnerability_scans')
    .select('*')
    .eq('user_id', user.id)
    .is('deleted_at', null)
    .order('created_at', { ascending: false })

  if (error) throw error
  return data || []
}

export async function getVulnerabilityScan(id: string) {
  const supabase = createServerActionClient({ cookies })

  const { data: { user } } = await supabase.auth.getUser()
  if (!user) throw new Error('Not authenticated')

  const { data, error } = await supabase
    .from('vulnerability_scans')
    .select('*')
    .eq('id', id)
    .eq('user_id', user.id)
    .single()

  if (error) throw error
  return data
}

// Vulnerability Actions
export async function createVulnerability(input: VulnerabilityInput) {
  const supabase = createServerActionClient({ cookies })

  const { data: { user } } = await supabase.auth.getUser()
  if (!user) throw new Error('Not authenticated')

  const { data, error } = await supabase
    .from('vulnerabilities')
    .insert([{
      ...input,
      status: 'open',
      exploit_available: input.exploit_available ?? false,
      patch_available: input.patch_available ?? false
    }])
    .select()
    .single()

  if (error) throw error

  // Update scan vulnerability counts
  const countField = `vuln_${input.severity}`
  await supabase.rpc('increment_vuln_count', {
    scan_id: input.scan_id,
    field_name: countField
  })

  revalidatePath('/dashboard/vulnerability-scan-v2')
  return data
}

export async function updateVulnerability(id: string, updates: Partial<VulnerabilityInput>) {
  const supabase = createServerActionClient({ cookies })

  const { data, error } = await supabase
    .from('vulnerabilities')
    .update({ ...updates, updated_at: new Date().toISOString() })
    .eq('id', id)
    .select()
    .single()

  if (error) throw error

  revalidatePath('/dashboard/vulnerability-scan-v2')
  return data
}

export async function fixVulnerability(id: string, notes?: string) {
  const supabase = createServerActionClient({ cookies })

  const { data: { user } } = await supabase.auth.getUser()
  if (!user) throw new Error('Not authenticated')

  const { data, error } = await supabase
    .from('vulnerabilities')
    .update({
      status: 'fixed',
      fixed_at: new Date().toISOString(),
      fixed_by: user.id,
      remediation_notes: notes,
      updated_at: new Date().toISOString()
    })
    .eq('id', id)
    .select()
    .single()

  if (error) throw error

  revalidatePath('/dashboard/vulnerability-scan-v2')
  return data
}

export async function ignoreVulnerability(id: string, reason?: string) {
  const supabase = createServerActionClient({ cookies })

  const { data, error } = await supabase
    .from('vulnerabilities')
    .update({
      status: 'ignored',
      remediation_notes: reason,
      updated_at: new Date().toISOString()
    })
    .eq('id', id)
    .select()
    .single()

  if (error) throw error

  revalidatePath('/dashboard/vulnerability-scan-v2')
  return data
}

export async function markVulnerabilityFalsePositive(id: string, reason?: string) {
  const supabase = createServerActionClient({ cookies })

  const { data, error } = await supabase
    .from('vulnerabilities')
    .update({
      status: 'false-positive',
      remediation_notes: reason,
      updated_at: new Date().toISOString()
    })
    .eq('id', id)
    .select()
    .single()

  if (error) throw error

  revalidatePath('/dashboard/vulnerability-scan-v2')
  return data
}

export async function getVulnerabilities(scanId: string) {
  const supabase = createServerActionClient({ cookies })

  const { data, error } = await supabase
    .from('vulnerabilities')
    .select('*')
    .eq('scan_id', scanId)
    .order('severity', { ascending: false })

  if (error) throw error
  return data || []
}
