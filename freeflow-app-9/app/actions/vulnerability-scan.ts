'use server'

import { createClient } from '@/lib/supabase/server'
import { cookies } from 'next/headers'
import { revalidatePath } from 'next/cache'
import { actionSuccess, actionError, ActionResult } from '@/lib/api/response'
import { createFeatureLogger } from '@/lib/logger'

const logger = createFeatureLogger('vulnerability-scan-actions')

// Types
export interface VulnerabilityScanInput {
  name: string
  description?: string
  scan_type: 'dependency' | 'code' | 'container' | 'infrastructure' | 'web-application' | 'network' | 'api'
  scanner?: string
  scanner_version?: string
  target?: string
  target_type?: string
  schedule_cron?: string
  next_scheduled_at?: string
  config?: Record<string, any>
  tags?: string[]
  metadata?: Record<string, any>
}

export interface VulnerabilityInput {
  scan_id: string
  title: string
  description?: string
  severity: 'info' | 'low' | 'medium' | 'high' | 'critical'
  category?: string
  package_name?: string
  package_version?: string
  fixed_version?: string
  file_path?: string
  line_number?: number
  cve_id?: string
  cwe_id?: string
  cvss_score?: number
  cvss_vector?: string
  exploit_available?: boolean
  patch_available?: boolean
  reference_urls?: string[]
  metadata?: Record<string, any>
}

// Vulnerability Scan Actions
export async function createVulnerabilityScan(input: VulnerabilityScanInput): Promise<ActionResult<any>> {
  try {
    const supabase = createClient()
    const { data: { user } } = await supabase.auth.getUser()
    if (!user) return actionError('Not authenticated', 'UNAUTHORIZED')

    const { data, error } = await supabase
      .from('vulnerability_scans')
      .insert([{
        ...input,
        user_id: user.id,
        status: 'scheduled',
        scanned_items: 0,
        vuln_critical: 0,
        vuln_high: 0,
        vuln_medium: 0,
        vuln_low: 0,
        vuln_info: 0,
        fixed_count: 0,
        ignored_count: 0,
        false_positive_count: 0,
        duration_seconds: 0
      }])
      .select()
      .single()

    if (error) {
      logger.error('Failed to create vulnerability scan', { error, userId: user.id })
      return actionError(error.message, 'DATABASE_ERROR')
    }

    revalidatePath('/dashboard/vulnerability-scan-v2')
    logger.info('Vulnerability scan created', { userId: user.id, scanId: data.id })
    return actionSuccess(data, 'Vulnerability scan created successfully')
  } catch (error: any) {
    logger.error('Unexpected error in createVulnerabilityScan', { error })
    return actionError('An unexpected error occurred', 'INTERNAL_ERROR')
  }
}

export async function updateVulnerabilityScan(id: string, updates: Partial<VulnerabilityScanInput>): Promise<ActionResult<any>> {
  try {
    const supabase = createClient()
    const { data: { user } } = await supabase.auth.getUser()
    if (!user) return actionError('Not authenticated', 'UNAUTHORIZED')

    const { data, error } = await supabase
      .from('vulnerability_scans')
      .update({ ...updates, updated_at: new Date().toISOString() })
      .eq('id', id)
      .eq('user_id', user.id)
      .select()
      .single()

    if (error) {
      logger.error('Failed to update vulnerability scan', { error, userId: user.id, scanId: id })
      return actionError(error.message, 'DATABASE_ERROR')
    }

    revalidatePath('/dashboard/vulnerability-scan-v2')
    logger.info('Vulnerability scan updated', { userId: user.id, scanId: id })
    return actionSuccess(data, 'Vulnerability scan updated successfully')
  } catch (error: any) {
    logger.error('Unexpected error in updateVulnerabilityScan', { error })
    return actionError('An unexpected error occurred', 'INTERNAL_ERROR')
  }
}

export async function deleteVulnerabilityScan(id: string): Promise<ActionResult<any>> {
  try {
    const supabase = createClient()
    const { data: { user } } = await supabase.auth.getUser()
    if (!user) return actionError('Not authenticated', 'UNAUTHORIZED')

    const { error } = await supabase
      .from('vulnerability_scans')
      .update({ deleted_at: new Date().toISOString() })
      .eq('id', id)
      .eq('user_id', user.id)

    if (error) {
      logger.error('Failed to delete vulnerability scan', { error, userId: user.id, scanId: id })
      return actionError(error.message, 'DATABASE_ERROR')
    }

    revalidatePath('/dashboard/vulnerability-scan-v2')
    logger.info('Vulnerability scan deleted', { userId: user.id, scanId: id })
    return actionSuccess({ id }, 'Vulnerability scan deleted successfully')
  } catch (error: any) {
    logger.error('Unexpected error in deleteVulnerabilityScan', { error })
    return actionError('An unexpected error occurred', 'INTERNAL_ERROR')
  }
}

export async function startVulnerabilityScan(id: string): Promise<ActionResult<any>> {
  try {
    const supabase = createClient()
    const { data: { user } } = await supabase.auth.getUser()
    if (!user) return actionError('Not authenticated', 'UNAUTHORIZED')

    const { data, error } = await supabase
      .from('vulnerability_scans')
      .update({
        status: 'in-progress',
        started_at: new Date().toISOString(),
        updated_at: new Date().toISOString()
      })
      .eq('id', id)
      .eq('user_id', user.id)
      .select()
      .single()

    if (error) {
      logger.error('Failed to start vulnerability scan', { error, userId: user.id, scanId: id })
      return actionError(error.message, 'DATABASE_ERROR')
    }

    revalidatePath('/dashboard/vulnerability-scan-v2')
    logger.info('Vulnerability scan started', { userId: user.id, scanId: id })
    return actionSuccess(data, 'Vulnerability scan started successfully')
  } catch (error: any) {
    logger.error('Unexpected error in startVulnerabilityScan', { error })
    return actionError('An unexpected error occurred', 'INTERNAL_ERROR')
  }
}

export async function completeVulnerabilityScan(id: string, success: boolean = true): Promise<ActionResult<any>> {
  try {
    const supabase = createClient()
    const { data: { user } } = await supabase.auth.getUser()
    if (!user) return actionError('Not authenticated', 'UNAUTHORIZED')

    const { data: scan } = await supabase
      .from('vulnerability_scans')
      .select('started_at')
      .eq('id', id)
      .single()

    const startedAt = scan?.started_at ? new Date(scan.started_at) : new Date()
    const duration = Math.floor((Date.now() - startedAt.getTime()) / 1000)

    const { data, error } = await supabase
      .from('vulnerability_scans')
      .update({
        status: success ? 'completed' : 'failed',
        completed_at: new Date().toISOString(),
        duration_seconds: duration,
        updated_at: new Date().toISOString()
      })
      .eq('id', id)
      .eq('user_id', user.id)
      .select()
      .single()

    if (error) {
      logger.error('Failed to complete vulnerability scan', { error, userId: user.id, scanId: id })
      return actionError(error.message, 'DATABASE_ERROR')
    }

    revalidatePath('/dashboard/vulnerability-scan-v2')
    logger.info('Vulnerability scan completed', { userId: user.id, scanId: id, success })
    return actionSuccess(data, 'Vulnerability scan completed successfully')
  } catch (error: any) {
    logger.error('Unexpected error in completeVulnerabilityScan', { error })
    return actionError('An unexpected error occurred', 'INTERNAL_ERROR')
  }
}

export async function cancelVulnerabilityScan(id: string): Promise<ActionResult<any>> {
  try {
    const supabase = createClient()
    const { data: { user } } = await supabase.auth.getUser()
    if (!user) return actionError('Not authenticated', 'UNAUTHORIZED')

    const { data, error } = await supabase
      .from('vulnerability_scans')
      .update({
        status: 'cancelled',
        updated_at: new Date().toISOString()
      })
      .eq('id', id)
      .eq('user_id', user.id)
      .select()
      .single()

    if (error) {
      logger.error('Failed to cancel vulnerability scan', { error, userId: user.id, scanId: id })
      return actionError(error.message, 'DATABASE_ERROR')
    }

    revalidatePath('/dashboard/vulnerability-scan-v2')
    logger.info('Vulnerability scan cancelled', { userId: user.id, scanId: id })
    return actionSuccess(data, 'Vulnerability scan cancelled successfully')
  } catch (error: any) {
    logger.error('Unexpected error in cancelVulnerabilityScan', { error })
    return actionError('An unexpected error occurred', 'INTERNAL_ERROR')
  }
}

export async function rescanVulnerability(id: string): Promise<ActionResult<any>> {
  try {
    const supabase = createClient()
    const { data: { user } } = await supabase.auth.getUser()
    if (!user) return actionError('Not authenticated', 'UNAUTHORIZED')

    const { data: original } = await supabase
      .from('vulnerability_scans')
      .select('*')
      .eq('id', id)
      .eq('user_id', user.id)
      .single()

    if (!original) return actionError('Scan not found', 'NOT_FOUND')

    const { data, error } = await supabase
      .from('vulnerability_scans')
      .insert([{
        user_id: user.id,
        name: original.name,
        description: original.description,
        scan_type: original.scan_type,
        scanner: original.scanner,
        scanner_version: original.scanner_version,
        target: original.target,
        target_type: original.target_type,
        config: original.config,
        tags: original.tags,
        status: 'scheduled',
        scanned_items: 0,
        vuln_critical: 0,
        vuln_high: 0,
        vuln_medium: 0,
        vuln_low: 0,
        vuln_info: 0,
        fixed_count: 0,
        ignored_count: 0,
        false_positive_count: 0,
        duration_seconds: 0
      }])
      .select()
      .single()

    if (error) {
      logger.error('Failed to rescan vulnerability', { error, userId: user.id, scanId: id })
      return actionError(error.message, 'DATABASE_ERROR')
    }

    revalidatePath('/dashboard/vulnerability-scan-v2')
    logger.info('Vulnerability rescan created', { userId: user.id, originalScanId: id, newScanId: data.id })
    return actionSuccess(data, 'Vulnerability rescan created successfully')
  } catch (error: any) {
    logger.error('Unexpected error in rescanVulnerability', { error })
    return actionError('An unexpected error occurred', 'INTERNAL_ERROR')
  }
}

export async function getVulnerabilityScans(): Promise<ActionResult<any>> {
  try {
    const supabase = createClient()
    const { data: { user } } = await supabase.auth.getUser()
    if (!user) return actionError('Not authenticated', 'UNAUTHORIZED')

    const { data, error } = await supabase
      .from('vulnerability_scans')
      .select('*')
      .eq('user_id', user.id)
      .is('deleted_at', null)
      .order('created_at', { ascending: false })

    if (error) {
      logger.error('Failed to get vulnerability scans', { error, userId: user.id })
      return actionError(error.message, 'DATABASE_ERROR')
    }

    logger.info('Vulnerability scans retrieved', { userId: user.id, count: data?.length })
    return actionSuccess(data || [], 'Vulnerability scans retrieved successfully')
  } catch (error: any) {
    logger.error('Unexpected error in getVulnerabilityScans', { error })
    return actionError('An unexpected error occurred', 'INTERNAL_ERROR')
  }
}

export async function getVulnerabilityScan(id: string): Promise<ActionResult<any>> {
  try {
    const supabase = createClient()
    const { data: { user } } = await supabase.auth.getUser()
    if (!user) return actionError('Not authenticated', 'UNAUTHORIZED')

    const { data, error } = await supabase
      .from('vulnerability_scans')
      .select('*')
      .eq('id', id)
      .eq('user_id', user.id)
      .single()

    if (error) {
      logger.error('Failed to get vulnerability scan', { error, userId: user.id, scanId: id })
      return actionError(error.message, 'DATABASE_ERROR')
    }

    logger.info('Vulnerability scan retrieved', { userId: user.id, scanId: id })
    return actionSuccess(data, 'Vulnerability scan retrieved successfully')
  } catch (error: any) {
    logger.error('Unexpected error in getVulnerabilityScan', { error })
    return actionError('An unexpected error occurred', 'INTERNAL_ERROR')
  }
}

// Vulnerability Actions
export async function createVulnerability(input: VulnerabilityInput): Promise<ActionResult<any>> {
  try {
    const supabase = createClient()
    const { data: { user } } = await supabase.auth.getUser()
    if (!user) return actionError('Not authenticated', 'UNAUTHORIZED')

    const { data, error } = await supabase
      .from('vulnerabilities')
      .insert([{
        ...input,
        status: 'open',
        exploit_available: input.exploit_available ?? false,
        patch_available: input.patch_available ?? false
      }])
      .select()
      .single()

    if (error) {
      logger.error('Failed to create vulnerability', { error, userId: user.id })
      return actionError(error.message, 'DATABASE_ERROR')
    }

    // Update scan vulnerability counts
    const countField = `vuln_${input.severity}`
    await supabase.rpc('increment_vuln_count', {
      scan_id: input.scan_id,
      field_name: countField
    })

    revalidatePath('/dashboard/vulnerability-scan-v2')
    logger.info('Vulnerability created', { userId: user.id, vulnerabilityId: data.id })
    return actionSuccess(data, 'Vulnerability created successfully')
  } catch (error: any) {
    logger.error('Unexpected error in createVulnerability', { error })
    return actionError('An unexpected error occurred', 'INTERNAL_ERROR')
  }
}

export async function updateVulnerability(id: string, updates: Partial<VulnerabilityInput>): Promise<ActionResult<any>> {
  try {
    const supabase = createClient()

    const { data, error } = await supabase
      .from('vulnerabilities')
      .update({ ...updates, updated_at: new Date().toISOString() })
      .eq('id', id)
      .select()
      .single()

    if (error) {
      logger.error('Failed to update vulnerability', { error, vulnerabilityId: id })
      return actionError(error.message, 'DATABASE_ERROR')
    }

    revalidatePath('/dashboard/vulnerability-scan-v2')
    logger.info('Vulnerability updated', { vulnerabilityId: id })
    return actionSuccess(data, 'Vulnerability updated successfully')
  } catch (error: any) {
    logger.error('Unexpected error in updateVulnerability', { error })
    return actionError('An unexpected error occurred', 'INTERNAL_ERROR')
  }
}

export async function fixVulnerability(id: string, notes?: string): Promise<ActionResult<any>> {
  try {
    const supabase = createClient()
    const { data: { user } } = await supabase.auth.getUser()
    if (!user) return actionError('Not authenticated', 'UNAUTHORIZED')

    const { data, error } = await supabase
      .from('vulnerabilities')
      .update({
        status: 'fixed',
        fixed_at: new Date().toISOString(),
        fixed_by: user.id,
        remediation_notes: notes,
        updated_at: new Date().toISOString()
      })
      .eq('id', id)
      .select()
      .single()

    if (error) {
      logger.error('Failed to fix vulnerability', { error, userId: user.id, vulnerabilityId: id })
      return actionError(error.message, 'DATABASE_ERROR')
    }

    revalidatePath('/dashboard/vulnerability-scan-v2')
    logger.info('Vulnerability fixed', { userId: user.id, vulnerabilityId: id })
    return actionSuccess(data, 'Vulnerability fixed successfully')
  } catch (error: any) {
    logger.error('Unexpected error in fixVulnerability', { error })
    return actionError('An unexpected error occurred', 'INTERNAL_ERROR')
  }
}

export async function ignoreVulnerability(id: string, reason?: string): Promise<ActionResult<any>> {
  try {
    const supabase = createClient()

    const { data, error } = await supabase
      .from('vulnerabilities')
      .update({
        status: 'ignored',
        remediation_notes: reason,
        updated_at: new Date().toISOString()
      })
      .eq('id', id)
      .select()
      .single()

    if (error) {
      logger.error('Failed to ignore vulnerability', { error, vulnerabilityId: id })
      return actionError(error.message, 'DATABASE_ERROR')
    }

    revalidatePath('/dashboard/vulnerability-scan-v2')
    logger.info('Vulnerability ignored', { vulnerabilityId: id })
    return actionSuccess(data, 'Vulnerability ignored successfully')
  } catch (error: any) {
    logger.error('Unexpected error in ignoreVulnerability', { error })
    return actionError('An unexpected error occurred', 'INTERNAL_ERROR')
  }
}

export async function markVulnerabilityFalsePositive(id: string, reason?: string): Promise<ActionResult<any>> {
  try {
    const supabase = createClient()

    const { data, error } = await supabase
      .from('vulnerabilities')
      .update({
        status: 'false-positive',
        remediation_notes: reason,
        updated_at: new Date().toISOString()
      })
      .eq('id', id)
      .select()
      .single()

    if (error) {
      logger.error('Failed to mark vulnerability as false positive', { error, vulnerabilityId: id })
      return actionError(error.message, 'DATABASE_ERROR')
    }

    revalidatePath('/dashboard/vulnerability-scan-v2')
    logger.info('Vulnerability marked as false positive', { vulnerabilityId: id })
    return actionSuccess(data, 'Vulnerability marked as false positive successfully')
  } catch (error: any) {
    logger.error('Unexpected error in markVulnerabilityFalsePositive', { error })
    return actionError('An unexpected error occurred', 'INTERNAL_ERROR')
  }
}

export async function getVulnerabilities(scanId: string): Promise<ActionResult<any>> {
  try {
    const supabase = createClient()

    const { data, error } = await supabase
      .from('vulnerabilities')
      .select('*')
      .eq('scan_id', scanId)
      .order('severity', { ascending: false })

    if (error) {
      logger.error('Failed to get vulnerabilities', { error, scanId })
      return actionError(error.message, 'DATABASE_ERROR')
    }

    logger.info('Vulnerabilities retrieved', { scanId, count: data?.length })
    return actionSuccess(data || [], 'Vulnerabilities retrieved successfully')
  } catch (error: any) {
    logger.error('Unexpected error in getVulnerabilities', { error })
    return actionError('An unexpected error occurred', 'INTERNAL_ERROR')
  }
}
