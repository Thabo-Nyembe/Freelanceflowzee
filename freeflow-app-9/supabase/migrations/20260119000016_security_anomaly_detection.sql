-- Migration: Security Anomaly Detection
-- Phase 9.6 of A+++ Implementation
-- Created: January 2026

-- ============================================================================
-- SECURITY EVENTS TABLE
-- Stores all security-related events for analysis
-- ============================================================================

CREATE TABLE IF NOT EXISTS security_events (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE SET NULL,
    organization_id UUID REFERENCES organizations(id) ON DELETE CASCADE,
    event_type VARCHAR(50) NOT NULL,
    ip_address INET NOT NULL,
    user_agent TEXT,
    location JSONB DEFAULT '{}',
    metadata JSONB DEFAULT '{}',
    risk_score INTEGER DEFAULT 0 CHECK (risk_score >= 0 AND risk_score <= 100),
    timestamp TIMESTAMPTZ NOT NULL DEFAULT NOW(),

    CONSTRAINT valid_event_type CHECK (
        event_type IN (
            'login_attempt', 'login_success', 'login_failure', 'logout',
            'password_change', 'mfa_enabled', 'mfa_disabled', 'api_call',
            'permission_change', 'data_export', 'session_created', 'session_revoked',
            'suspicious_activity'
        )
    )
);

CREATE INDEX IF NOT EXISTS idx_security_events_user ON security_events(user_id);
CREATE INDEX IF NOT EXISTS idx_security_events_org ON security_events(organization_id);
CREATE INDEX IF NOT EXISTS idx_security_events_type ON security_events(event_type);
CREATE INDEX IF NOT EXISTS idx_security_events_ip ON security_events(ip_address);
CREATE INDEX IF NOT EXISTS idx_security_events_timestamp ON security_events(timestamp DESC);
CREATE INDEX IF NOT EXISTS idx_security_events_risk ON security_events(risk_score) WHERE risk_score > 50;
CREATE INDEX IF NOT EXISTS idx_security_events_user_type_time ON security_events(user_id, event_type, timestamp DESC);

-- ============================================================================
-- SECURITY ALERTS TABLE
-- Stores security alerts generated by anomaly detection
-- ============================================================================

CREATE TABLE IF NOT EXISTS security_alerts (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE SET NULL,
    organization_id UUID REFERENCES organizations(id) ON DELETE CASCADE,
    alert_type VARCHAR(100) NOT NULL,
    severity VARCHAR(20) NOT NULL CHECK (severity IN ('low', 'medium', 'high', 'critical')),
    status VARCHAR(20) NOT NULL DEFAULT 'new' CHECK (status IN ('new', 'investigating', 'resolved', 'false_positive')),
    title VARCHAR(255) NOT NULL,
    description TEXT,
    details JSONB DEFAULT '{}',
    related_events UUID[] DEFAULT '{}',
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    resolved_at TIMESTAMPTZ,
    resolved_by UUID REFERENCES users(id) ON DELETE SET NULL
);

CREATE INDEX IF NOT EXISTS idx_security_alerts_user ON security_alerts(user_id);
CREATE INDEX IF NOT EXISTS idx_security_alerts_org ON security_alerts(organization_id);
CREATE INDEX IF NOT EXISTS idx_security_alerts_type ON security_alerts(alert_type);
CREATE INDEX IF NOT EXISTS idx_security_alerts_severity ON security_alerts(severity);
CREATE INDEX IF NOT EXISTS idx_security_alerts_status ON security_alerts(status);
CREATE INDEX IF NOT EXISTS idx_security_alerts_created ON security_alerts(created_at DESC);
CREATE INDEX IF NOT EXISTS idx_security_alerts_open ON security_alerts(organization_id, status) WHERE status IN ('new', 'investigating');

-- ============================================================================
-- SECURITY ALERT NOTES TABLE
-- Notes and comments on security alerts
-- ============================================================================

CREATE TABLE IF NOT EXISTS security_alert_notes (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    alert_id UUID NOT NULL REFERENCES security_alerts(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    content TEXT NOT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_security_alert_notes_alert ON security_alert_notes(alert_id);

-- ============================================================================
-- ANOMALY RULES TABLE
-- Custom anomaly detection rules
-- ============================================================================

CREATE TABLE IF NOT EXISTS anomaly_rules (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    organization_id UUID REFERENCES organizations(id) ON DELETE CASCADE,
    name VARCHAR(255) NOT NULL,
    description TEXT,
    rule_type VARCHAR(50) NOT NULL,
    conditions JSONB NOT NULL DEFAULT '[]',
    actions JSONB NOT NULL DEFAULT '[]',
    severity VARCHAR(20) NOT NULL CHECK (severity IN ('low', 'medium', 'high', 'critical')),
    is_active BOOLEAN NOT NULL DEFAULT true,
    is_system BOOLEAN NOT NULL DEFAULT false,
    cooldown_minutes INTEGER DEFAULT 60,
    last_triggered_at TIMESTAMPTZ,
    trigger_count INTEGER DEFAULT 0,
    created_by UUID REFERENCES users(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_anomaly_rules_org ON anomaly_rules(organization_id);
CREATE INDEX IF NOT EXISTS idx_anomaly_rules_active ON anomaly_rules(organization_id) WHERE is_active = true;
CREATE INDEX IF NOT EXISTS idx_anomaly_rules_system ON anomaly_rules(is_system) WHERE is_system = true;

-- ============================================================================
-- USER BEHAVIOR PROFILES TABLE
-- Learned behavioral patterns for anomaly detection
-- ============================================================================

CREATE TABLE IF NOT EXISTS user_behavior_profiles (
    user_id UUID PRIMARY KEY REFERENCES users(id) ON DELETE CASCADE,
    typical_login_hours INTEGER[] DEFAULT '{}',
    typical_locations TEXT[] DEFAULT '{}',
    typical_devices TEXT[] DEFAULT '{}',
    typical_ips INET[] DEFAULT '{}',
    avg_session_duration INTEGER DEFAULT 0,
    avg_api_calls_per_hour NUMERIC(10,2) DEFAULT 0,
    last_updated TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- ============================================================================
-- THREAT INTELLIGENCE TABLE
-- IP reputation and threat intelligence data
-- ============================================================================

CREATE TABLE IF NOT EXISTS threat_intelligence (
    ip_address INET PRIMARY KEY,
    is_tor_exit BOOLEAN DEFAULT false,
    is_vpn BOOLEAN DEFAULT false,
    is_proxy BOOLEAN DEFAULT false,
    is_hosting BOOLEAN DEFAULT false,
    is_known_attacker BOOLEAN DEFAULT false,
    threat_score INTEGER DEFAULT 0 CHECK (threat_score >= 0 AND threat_score <= 100),
    last_checked TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'
);

CREATE INDEX IF NOT EXISTS idx_threat_intel_score ON threat_intelligence(threat_score) WHERE threat_score >= 50;
CREATE INDEX IF NOT EXISTS idx_threat_intel_attacker ON threat_intelligence(is_known_attacker) WHERE is_known_attacker = true;

-- ============================================================================
-- BLOCKED IPS TABLE
-- Temporarily or permanently blocked IP addresses
-- ============================================================================

CREATE TABLE IF NOT EXISTS blocked_ips (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    ip_address INET NOT NULL,
    organization_id UUID REFERENCES organizations(id) ON DELETE CASCADE,
    reason TEXT,
    blocked_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    expires_at TIMESTAMPTZ,
    blocked_by UUID REFERENCES users(id) ON DELETE SET NULL,
    is_permanent BOOLEAN DEFAULT false,

    CONSTRAINT unique_blocked_ip UNIQUE (ip_address, organization_id)
);

CREATE INDEX IF NOT EXISTS idx_blocked_ips_address ON blocked_ips(ip_address);
CREATE INDEX IF NOT EXISTS idx_blocked_ips_org ON blocked_ips(organization_id);
CREATE INDEX IF NOT EXISTS idx_blocked_ips_active ON blocked_ips(ip_address) WHERE expires_at IS NULL OR expires_at > NOW();

-- ============================================================================
-- RLS POLICIES
-- ============================================================================

ALTER TABLE security_events ENABLE ROW LEVEL SECURITY;
ALTER TABLE security_alerts ENABLE ROW LEVEL SECURITY;
ALTER TABLE security_alert_notes ENABLE ROW LEVEL SECURITY;
ALTER TABLE anomaly_rules ENABLE ROW LEVEL SECURITY;
ALTER TABLE user_behavior_profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE threat_intelligence ENABLE ROW LEVEL SECURITY;
ALTER TABLE blocked_ips ENABLE ROW LEVEL SECURITY;

-- Security Events policies
CREATE POLICY "Users can view own events"
ON security_events FOR SELECT
TO authenticated
USING (user_id = auth.uid());

CREATE POLICY "Org admins can view org events"
ON security_events FOR SELECT
TO authenticated
USING (
    organization_id IN (
        SELECT organization_id FROM organization_members
        WHERE user_id = auth.uid()
        AND role IN ('admin', 'owner')
    )
);

CREATE POLICY "Service role can manage events"
ON security_events FOR ALL
TO service_role
USING (true)
WITH CHECK (true);

-- Security Alerts policies
CREATE POLICY "Users can view own alerts"
ON security_alerts FOR SELECT
TO authenticated
USING (user_id = auth.uid());

CREATE POLICY "Org admins can view org alerts"
ON security_alerts FOR SELECT
TO authenticated
USING (
    organization_id IN (
        SELECT organization_id FROM organization_members
        WHERE user_id = auth.uid()
        AND role IN ('admin', 'owner')
    )
);

CREATE POLICY "Org admins can update org alerts"
ON security_alerts FOR UPDATE
TO authenticated
USING (
    organization_id IN (
        SELECT organization_id FROM organization_members
        WHERE user_id = auth.uid()
        AND role IN ('admin', 'owner')
    )
);

CREATE POLICY "Service role can manage alerts"
ON security_alerts FOR ALL
TO service_role
USING (true)
WITH CHECK (true);

-- Alert Notes policies
CREATE POLICY "Users can view notes on accessible alerts"
ON security_alert_notes FOR SELECT
TO authenticated
USING (
    alert_id IN (
        SELECT id FROM security_alerts
        WHERE user_id = auth.uid()
        OR organization_id IN (
            SELECT organization_id FROM organization_members
            WHERE user_id = auth.uid()
            AND role IN ('admin', 'owner')
        )
    )
);

CREATE POLICY "Users can add notes to accessible alerts"
ON security_alert_notes FOR INSERT
TO authenticated
WITH CHECK (
    alert_id IN (
        SELECT id FROM security_alerts
        WHERE user_id = auth.uid()
        OR organization_id IN (
            SELECT organization_id FROM organization_members
            WHERE user_id = auth.uid()
            AND role IN ('admin', 'owner')
        )
    )
);

-- Anomaly Rules policies
CREATE POLICY "Org admins can view rules"
ON anomaly_rules FOR SELECT
TO authenticated
USING (
    is_system = true
    OR organization_id IN (
        SELECT organization_id FROM organization_members
        WHERE user_id = auth.uid()
        AND role IN ('admin', 'owner')
    )
);

CREATE POLICY "Org admins can manage rules"
ON anomaly_rules FOR ALL
TO authenticated
USING (
    is_system = false
    AND organization_id IN (
        SELECT organization_id FROM organization_members
        WHERE user_id = auth.uid()
        AND role IN ('admin', 'owner')
    )
)
WITH CHECK (
    is_system = false
    AND organization_id IN (
        SELECT organization_id FROM organization_members
        WHERE user_id = auth.uid()
        AND role IN ('admin', 'owner')
    )
);

CREATE POLICY "Service role can manage rules"
ON anomaly_rules FOR ALL
TO service_role
USING (true)
WITH CHECK (true);

-- User Behavior Profiles policies
CREATE POLICY "Users can view own profile"
ON user_behavior_profiles FOR SELECT
TO authenticated
USING (user_id = auth.uid());

CREATE POLICY "Service role can manage profiles"
ON user_behavior_profiles FOR ALL
TO service_role
USING (true)
WITH CHECK (true);

-- Threat Intelligence policies (service role only)
CREATE POLICY "Service role can manage threat intel"
ON threat_intelligence FOR ALL
TO service_role
USING (true)
WITH CHECK (true);

-- Blocked IPs policies
CREATE POLICY "Org admins can view blocked IPs"
ON blocked_ips FOR SELECT
TO authenticated
USING (
    organization_id IN (
        SELECT organization_id FROM organization_members
        WHERE user_id = auth.uid()
        AND role IN ('admin', 'owner')
    )
);

CREATE POLICY "Org admins can manage blocked IPs"
ON blocked_ips FOR ALL
TO authenticated
USING (
    organization_id IN (
        SELECT organization_id FROM organization_members
        WHERE user_id = auth.uid()
        AND role IN ('admin', 'owner')
    )
)
WITH CHECK (
    organization_id IN (
        SELECT organization_id FROM organization_members
        WHERE user_id = auth.uid()
        AND role IN ('admin', 'owner')
    )
);

CREATE POLICY "Service role can manage blocked IPs"
ON blocked_ips FOR ALL
TO service_role
USING (true)
WITH CHECK (true);

-- ============================================================================
-- FUNCTIONS
-- ============================================================================

-- Function to get security alert statistics
CREATE OR REPLACE FUNCTION get_security_alert_stats(
    p_organization_id UUID DEFAULT NULL,
    p_user_id UUID DEFAULT NULL
)
RETURNS TABLE (
    total_alerts BIGINT,
    new_alerts BIGINT,
    investigating_alerts BIGINT,
    resolved_alerts BIGINT,
    false_positive_alerts BIGINT,
    critical_alerts BIGINT,
    high_alerts BIGINT,
    medium_alerts BIGINT,
    low_alerts BIGINT
)
LANGUAGE plpgsql
SECURITY DEFINER
STABLE
AS $$
BEGIN
    RETURN QUERY
    SELECT
        COUNT(*)::BIGINT as total_alerts,
        COUNT(*) FILTER (WHERE status = 'new')::BIGINT as new_alerts,
        COUNT(*) FILTER (WHERE status = 'investigating')::BIGINT as investigating_alerts,
        COUNT(*) FILTER (WHERE status = 'resolved')::BIGINT as resolved_alerts,
        COUNT(*) FILTER (WHERE status = 'false_positive')::BIGINT as false_positive_alerts,
        COUNT(*) FILTER (WHERE severity = 'critical')::BIGINT as critical_alerts,
        COUNT(*) FILTER (WHERE severity = 'high')::BIGINT as high_alerts,
        COUNT(*) FILTER (WHERE severity = 'medium')::BIGINT as medium_alerts,
        COUNT(*) FILTER (WHERE severity = 'low')::BIGINT as low_alerts
    FROM security_alerts
    WHERE (p_organization_id IS NULL OR organization_id = p_organization_id)
    AND (p_user_id IS NULL OR user_id = p_user_id);
END;
$$;

-- Function to get security event statistics
CREATE OR REPLACE FUNCTION get_security_event_stats(
    p_organization_id UUID DEFAULT NULL,
    p_user_id UUID DEFAULT NULL,
    p_days INTEGER DEFAULT 30
)
RETURNS TABLE (
    total_events BIGINT,
    high_risk_events BIGINT,
    login_attempts BIGINT,
    login_failures BIGINT,
    suspicious_activities BIGINT,
    unique_ips BIGINT,
    unique_countries BIGINT
)
LANGUAGE plpgsql
SECURITY DEFINER
STABLE
AS $$
BEGIN
    RETURN QUERY
    SELECT
        COUNT(*)::BIGINT as total_events,
        COUNT(*) FILTER (WHERE risk_score >= 50)::BIGINT as high_risk_events,
        COUNT(*) FILTER (WHERE event_type = 'login_attempt')::BIGINT as login_attempts,
        COUNT(*) FILTER (WHERE event_type = 'login_failure')::BIGINT as login_failures,
        COUNT(*) FILTER (WHERE event_type = 'suspicious_activity')::BIGINT as suspicious_activities,
        COUNT(DISTINCT ip_address)::BIGINT as unique_ips,
        COUNT(DISTINCT location->>'country_code')::BIGINT as unique_countries
    FROM security_events
    WHERE (p_organization_id IS NULL OR organization_id = p_organization_id)
    AND (p_user_id IS NULL OR user_id = p_user_id)
    AND timestamp >= NOW() - (p_days || ' days')::INTERVAL;
END;
$$;

-- Function to check if IP is blocked
CREATE OR REPLACE FUNCTION is_ip_blocked(
    p_ip_address INET,
    p_organization_id UUID DEFAULT NULL
)
RETURNS BOOLEAN
LANGUAGE plpgsql
SECURITY DEFINER
STABLE
AS $$
BEGIN
    RETURN EXISTS (
        SELECT 1 FROM blocked_ips
        WHERE ip_address = p_ip_address
        AND (organization_id IS NULL OR organization_id = p_organization_id)
        AND (expires_at IS NULL OR expires_at > NOW())
    );
END;
$$;

-- Function to clean up old security events
CREATE OR REPLACE FUNCTION cleanup_old_security_events(days_to_keep INTEGER DEFAULT 90)
RETURNS INTEGER
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    deleted_count INTEGER;
BEGIN
    DELETE FROM security_events
    WHERE timestamp < NOW() - (days_to_keep || ' days')::INTERVAL
    AND risk_score < 50;  -- Keep high-risk events longer

    GET DIAGNOSTICS deleted_count = ROW_COUNT;
    RETURN deleted_count;
END;
$$;

-- Function to cleanup expired blocked IPs
CREATE OR REPLACE FUNCTION cleanup_expired_blocked_ips()
RETURNS INTEGER
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    deleted_count INTEGER;
BEGIN
    DELETE FROM blocked_ips
    WHERE expires_at IS NOT NULL
    AND expires_at < NOW();

    GET DIAGNOSTICS deleted_count = ROW_COUNT;
    RETURN deleted_count;
END;
$$;

-- ============================================================================
-- TRIGGERS
-- ============================================================================

-- Update timestamp trigger for anomaly_rules
CREATE OR REPLACE FUNCTION update_anomaly_rules_timestamp()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$;

CREATE TRIGGER update_anomaly_rules_timestamp
BEFORE UPDATE ON anomaly_rules
FOR EACH ROW EXECUTE FUNCTION update_anomaly_rules_timestamp();

-- ============================================================================
-- DEFAULT SYSTEM RULES
-- ============================================================================

INSERT INTO anomaly_rules (
    id,
    name,
    description,
    rule_type,
    conditions,
    actions,
    severity,
    is_system,
    cooldown_minutes
) VALUES
(
    gen_random_uuid(),
    'Brute Force Detection',
    'Detect multiple failed login attempts from the same IP',
    'brute_force',
    '[{"field": "event_type", "operator": "eq", "value": "login_failure"}, {"field": "count", "operator": "gte", "value": 5}]',
    '[{"type": "alert"}, {"type": "block_ip"}]',
    'high',
    true,
    30
),
(
    gen_random_uuid(),
    'Impossible Travel',
    'Detect logins from geographically distant locations in short time',
    'impossible_travel',
    '[{"field": "anomalies", "operator": "contains", "value": "impossible_travel"}]',
    '[{"type": "alert"}, {"type": "require_mfa"}]',
    'high',
    true,
    60
),
(
    gen_random_uuid(),
    'Critical Risk Score',
    'Alert on events with critical risk score',
    'risk_threshold',
    '[{"field": "risk_score", "operator": "gte", "value": 80}]',
    '[{"type": "alert"}, {"type": "notify_admin"}]',
    'critical',
    true,
    15
),
(
    gen_random_uuid(),
    'New Country Login',
    'Detect login from a new country',
    'geo_anomaly',
    '[{"field": "anomalies", "operator": "contains", "value": "geo_anomaly"}]',
    '[{"type": "alert"}]',
    'medium',
    true,
    1440
),
(
    gen_random_uuid(),
    'Suspicious Data Export',
    'Large data export detected',
    'data_exfiltration',
    '[{"field": "event_type", "operator": "eq", "value": "data_export"}, {"field": "metadata.size", "operator": "gt", "value": 1000000}]',
    '[{"type": "alert"}, {"type": "notify_admin"}]',
    'high',
    true,
    60
)
ON CONFLICT DO NOTHING;

-- ============================================================================
-- COMMENTS
-- ============================================================================

COMMENT ON TABLE security_events IS 'Security event log for anomaly detection';
COMMENT ON TABLE security_alerts IS 'Security alerts generated by anomaly detection';
COMMENT ON TABLE security_alert_notes IS 'Notes and investigation details on alerts';
COMMENT ON TABLE anomaly_rules IS 'Custom and system anomaly detection rules';
COMMENT ON TABLE user_behavior_profiles IS 'Learned user behavior patterns for anomaly detection';
COMMENT ON TABLE threat_intelligence IS 'IP reputation and threat intelligence cache';
COMMENT ON TABLE blocked_ips IS 'Temporarily or permanently blocked IP addresses';

-- ============================================================================
-- GRANTS
-- ============================================================================

GRANT USAGE ON SCHEMA public TO authenticated;
GRANT SELECT ON security_events TO authenticated;
GRANT SELECT, UPDATE ON security_alerts TO authenticated;
GRANT SELECT, INSERT ON security_alert_notes TO authenticated;
GRANT SELECT ON anomaly_rules TO authenticated;
GRANT SELECT ON user_behavior_profiles TO authenticated;
GRANT SELECT ON blocked_ips TO authenticated;

GRANT ALL ON security_events TO service_role;
GRANT ALL ON security_alerts TO service_role;
GRANT ALL ON security_alert_notes TO service_role;
GRANT ALL ON anomaly_rules TO service_role;
GRANT ALL ON user_behavior_profiles TO service_role;
GRANT ALL ON threat_intelligence TO service_role;
GRANT ALL ON blocked_ips TO service_role;

GRANT EXECUTE ON FUNCTION get_security_alert_stats(UUID, UUID) TO authenticated;
GRANT EXECUTE ON FUNCTION get_security_event_stats(UUID, UUID, INTEGER) TO authenticated;
GRANT EXECUTE ON FUNCTION is_ip_blocked(INET, UUID) TO authenticated;
GRANT EXECUTE ON FUNCTION cleanup_old_security_events(INTEGER) TO service_role;
GRANT EXECUTE ON FUNCTION cleanup_expired_blocked_ips() TO service_role;
